#include "hal_data.h"
#include "UART_SERIAL.h"
#include "CAN_SETTING.h"
#include "GPT.h"
#include "FND.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

void LED_SETTING();

/*           GPT           */
uint32_t SER_Timer_Period = 0x249F00;
/* ----------------------- */

/*          UART           */
uint8_t Rx_SERIAL_DATA[100]={0,};
uint8_t iter = 0;
uint32_t mailbox_number;
bool can_resetmode;
/* ----------------------- */

/*          FND            */
//                      0      1     2     3     4     5     6    7     8      9     I     d
 uint8_t number[12] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xD8, 0x80, 0x90, 0xF9, 0xA1};
 uint8_t print_data[4] = {0xFF, 0xFF, 0xFF, 0xFF};
 uint8_t FND_ID[2] = {0,};
 volatile uint8_t can_rx_id = 0;
 void R_FND_Print_Data(uint8_t *string);
 void R_FND_Display_Data(uint8_t digit, uint8_t data);
 void FND_Initial_Setting();
 void R_FND_Reset();
 /* ----------------------- */


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg); //UART START

    R_ICU_ExternalIrqOpen(&g_external_irq11_ctrl, &g_external_irq11_cfg); //Interrupt START
    R_ICU_ExternalIrqEnable(&g_external_irq11_ctrl);

    R_CAN_Open(&g_can0_ctrl, &g_can0_cfg); //CAN START

    SER_GPT_Setting(SER_Timer_Period); //GPT CFG
    R_GPT0->GTCR_b.CST = 1U; // GPT32EH0 Count Start

    LED_SETTING();
    FND_Initial_Setting();

    while(1)
    {
        if(can_rx_id > 0) R_FND_Print_Data(print_data);
    }


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif


}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

void LED_SETTING()
{
    R_PORT10->PDR_b.PDR8 = 1U;
    R_PORT10->PDR_b.PDR9 = 1U;
    R_PORT10->PDR_b.PDR10 = 1U;
    R_PORT11->PDR_b.PDR0 = 1U;

    R_PORT10->PODR_b.PODR8 = 1U;
    R_PORT10->PODR_b.PODR9 = 1U;
    R_PORT10->PODR_b.PODR10 = 1U;
    R_PORT11->PODR_b.PODR0 = 1U;
}


/* Callback function */
void UART_SERIAL_CALLBACK(uart_callback_args_t *p_args)
{
    // UART 8bit = 1byte (Transmission unit) When received, an interrupt occurs
    if(p_args->event == UART_EVENT_RX_CHAR)
    {
        Rx_SERIAL_DATA[iter] = (uint8_t)p_args->data; // 1바이트씩 다 옮기기
    }

    iter++;

    if(Rx_SERIAL_DATA[38] == '>')Rx_Serial_Convert(); // CAN channel, baudrate setting (last msg == '>')

    if(Rx_SERIAL_DATA[2] == 'A' ) //CAN ID and MSG transmission
    {

        switch(p_args->data)
        {
            case'>':
                CAN_MSG_Tx();
                break;
        }
    }
}


/* Callback function */
void IRQ11_CALLBACK(external_irq_callback_args_t *p_args) //Interrupt to turn off LED and clear buffer
{
    int i;

    for(i = 0; i < 100; i++)
    {
        Rx_SERIAL_DATA[i] = 0;
    }
    iter = 0;

    R_PORT10->PODR_b.PODR8 = 1U;
    R_PORT10->PODR_b.PODR9 = 1U;
    R_PORT10->PODR_b.PODR10 = 1U;
    R_PORT11->PODR_b.PODR0 = 1U;

}

/* Callback function */
void CAN_CALLBACK(can_callback_args_t *p_args)
{
    // CAN MSG Interruptions When One Frame Arrives
    if(p_args->event == CAN_EVENT_RX_COMPLETE)
    {
        // Rx CAN ID setting
        can_rx_id = p_args->frame.id;
        FND_ID[0] = number[(can_rx_id / 10)]; print_data[2] = FND_ID[0];
        can_rx_id %= 10;
        FND_ID[1] = number[can_rx_id]; print_data[3] = FND_ID[1];

        // Rx CAN DATA Processing
        CAN_MSG_Rx(p_args->frame.data);

        // Rx mailbox id settings
        mailbox_number = p_args->mailbox;
    }

}

void FND_Initial_Setting()
{

    print_data[0] = number[10];
    print_data[1] = number[11];

    /* 7-Segment LED Pin Output Setting */
    R_PORT3->PCNTR1_b.PDR |= (uint32_t)0x01E0;
    R_PORT6->PCNTR1_b.PDR |= (uint32_t)0x78F0;

    R_FND_Reset();
}

void R_FND_Reset()
{
    /* 7-Segment LED Pin State Initialization */
    R_PORT3->PCNTR1_b.PODR &= ~PODR_DIGIT_MASK & 0xFFFF;
    R_PORT6->PCNTR1_b.PODR |= PODR_PIN_MASK;
}

void R_FND_Print_Data(uint8_t *string)
{
    uint8_t idx = 0;

    if (sizeof(string) != DIGIT_INDEX)
        return;

    for (idx = 0; idx < DIGIT_INDEX ; idx++)
    {
        R_FND_Display_Data(idx, string[idx]);

    }
    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);
    R_FND_Reset();
    R_PORT3->PODR_b.PODR9 = 1;
}

void R_FND_Display_Data(uint8_t digit, uint8_t data)
{
    ////////////////// YOU MUST EDIT ONLY HERE ABOUT LOCAL VARIABLE //////////////////
    uint16_t high_nibble = (uint16_t)((data << PODR_INDEX_HIGH) & PODR_HIGH_MASK);
    uint16_t low_nibble = (uint16_t)((data << PODR_INDEX_LOW) & PODR_LOW_MASK);
    //////////////////////////////////////////////////////////////////////////////////

    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);
    R_FND_Reset();

    ///////////////////// YOU MUST EDIT ONLY HERE ABOUT EXERCISE /////////////////////
    /* 7-Segment Digit Selection */
    R_PORT3->PCNTR1_b.PODR = (uint16_t)((0x0010 << (1 + digit)) & PODR_DIGIT_MASK);

    /* 7-Segment LED Pin State Setting */
    R_PORT6->PCNTR1_b.PODR = high_nibble | low_nibble;
    //////////////////////////////////////////////////////////////////////////////////
}


