#include <g_DataStructure.h>
#include <g_DeviceDriver.h>
#include <g_Ethernet.h>
#include <g_TSN_TAS.h>
#include <hal_data.h>
#include <stdlib.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
void setEthFrame();
FSP_CPP_FOOTER

Eth_TX_Frame         EthTxFrame;                           // Ethernet Transmit Frame Structure
Eth_RX_Frame         EthRxFrame;                           // Ethernet Receive Frame Structure

Eth_TX_Frame         EthControl;
Eth_RX_Frame         EthInterrupt;

extern Eth_TX_Frame  EthPtFrame;
//extern Eth_RX_Frame  EthPrFrame;

uint8_t              gp_read_buffer[DATA_LINK_SIZE] = {0}; // Get Received Ethernet Message
uint32_t             read_frame_size = 0;                  // Length(Size) of Received Ethernet Message

volatile uint8_t     task_mode_14 = 0x01;

volatile uint8_t     TAS_PREM_STATE = TAS_PREEMPTION_ENABLE;
volatile uint8_t     TAS_OPTIMIZE_MODE = TAS_OPTIMIZE_DISABLE;

volatile uint8_t     gate_mode = 0;                        // TAS Gate Control Mode
volatile uint16_t    pSize = 0;                            // Preemptable Size in Guard Band
volatile uint16_t    pointer = TAS_GCL_NONE;               // Strict Priority Queue Index
volatile uint32_t    agt_counter = 0;                      // TSN Gate Control Global Timer Counter

volatile bool        ttState = false, pState = false, timeStampCheck = false;
volatile uint32_t    timeStamp = 0;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* Ethernet Frame Parameter: Destination Address, Source Address, VLAN Tag */
    preemState err = preemption_fail;
    uint8_t          ETH_DST_ADDR[6] = {0x00, 0x01, 0x00, 0x00, 0x54, 0x26}; // Destination MAC Address
    uint8_t          ETH_SRC_ADDR[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55}; // Source MAC Address
    uint16_t         ETH_VLAN_TAG[3] = {0x07, 0x01, 0x30};                   // IEEE 802.1Q VLAN Tag(=Header)

    /* RA6M3 Ethernet Initial Setting */
    R_Ethernet_Initial();
    R_ETHERC_EDMAC->EESIPR_b.TCIP = 0U; // Disable Transmit Interrupt Setting

    /* Generate Ethernet II Frame Table (Support IEEE 802.1Q) */
    getEthernetFrame(&EthTxFrame, ETH_DST_ADDR, ETH_SRC_ADDR, ETH_VLAN_TAG);
    getEthernetFrame(&EthPtFrame, ETH_DST_ADDR, ETH_SRC_ADDR, ETH_VLAN_TAG);
    getEthernetFrame(&EthControl, ETH_DST_ADDR, ETH_SRC_ADDR, ETH_VLAN_TAG);

    /* Linked-list-based Strict Priority Queue Initial Setting */
    RQ_Initial(0, Queue_Strict_Pirority);

    /* External Peripheral Device Initial Setting */
    pDevice_Driver();

    while(true)
    {
        pointer = TSN_TAS_Gate_Control(gate_mode);

        if (pointer != TAS_GCL_NONE)
        {
            switch(pointer)
            {
                case TAS_GCL_GUARD:
                    if (TAS_PREM_STATE)
                    {
                        err = TSN_TAS_Preemption();
                        EthPtFrame.payload[0] = (uint8_t)pointer;
                        if(preemption_success == err)
                        {
                            EthPtFrame.vlan_tag[1] = 0x20;
                            R_ETHER_Write(&g_ether0_ctrl, &EthPtFrame, ETH_HEADER_SIZE + pSize);
                        }
                    }
                    break;
                default:
                    EthRxFrame = *(RQ_dequeue(pointer, front_queue));
                    setEthFrame();
                    EthTxFrame.payload[0] = (uint8_t)pointer;
                    R_ETHER_Write(&g_ether0_ctrl, &EthTxFrame, ETH_HEADER_SIZE + EthRxFrame.eth_type);
                    break;
            }
        }
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void setEthFrame()
{
    EthTxFrame.vlan_tag[0] = (uint8_t)((EthTxFrame.vlan_tag[0] & 0x1F) | ((EthRxFrame.vlan_tag.PCP << 5) & 0xE0));

    EthTxFrame.eth_type[0] = (uint8_t)((EthRxFrame.eth_type >> 8) & 0xFF);
    EthTxFrame.eth_type[1] = (uint8_t)(EthRxFrame.eth_type & 0xFF);
    memcpy(EthTxFrame.payload, EthRxFrame.payload, (size_t)(EthRxFrame.eth_type - 1));
}

/* TSN Gate Control Global Timer: AGT0 */
void R_AGT0_Interrupt(timer_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    if(timeStampCheck)
        timeStamp++;

    // TAS Gate Control List Operation
    gate_mode = TSN_TAS_Gate_Mode_Select(agt_counter);

    if (agt_counter < TAS_GCL_CYCLE)
        agt_counter++;
    else
        agt_counter = 0;
}

/* Transmit Ethernet II Frame to PC */
void R_External_Interrupt(external_irq_callback_args_t *p_args)
{
    switch(p_args->channel)
    {
        case EXTERNAL_INTERRUPT_11: // Example Ethernet Message Transmit
            R_ETHER_Write(&g_ether0_ctrl, &EthTxFrame, DATA_LINK_SIZE);
            R_BSP_SoftwareDelay(96, BSP_DELAY_UNITS_MICROSECONDS);
            break;
        case EXTERNAL_INTERRUPT_12: // Select TSN TAS Preemption Mode
            TAS_PREM_STATE = TAS_PREEMPTION_DISABLE; // Only Guard Band
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_LOW);
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_HIGH);
            break;
        case EXTERNAL_INTERRUPT_13: // Select TSN TAS Normal Guard Band Mode
            TAS_PREM_STATE = TAS_PREEMPTION_ENABLE;  // Using TAS Preemption
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_09, BSP_IO_LEVEL_HIGH);
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_10_PIN_10, BSP_IO_LEVEL_LOW);
            break;
        case EXTERNAL_INTERRUPT_14:
            task_mode_14 ^= 0x01;
            if(task_mode_14)
                TAS_OPTIMIZE_MODE = TAS_OPTIMIZE_DISABLE;
            else
                TAS_OPTIMIZE_MODE = TAS_OPTIMIZE_ENABLE;
            R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_11_PIN_00, task_mode_14);
    }
}

/* Receive Ethernet Frame from PC */
void R_Ethernet_RxInterrupt(ether_callback_args_t *p_args)
{
    uint8_t pcp = 0;
    switch(p_args->event)
    {
        case ETHER_EVENT_INTERRUPT:
            // You must set "RACT" in the Receive Descriptor to 1 after occur Ethernet Handler.
            // If you use "R_ETHER_Read" HAL Function, Receive Descriptor is automatically set.
            R_ETHER_Read(&g_ether0_ctrl, (void *)gp_read_buffer, &read_frame_size);

            pcp = gp_read_buffer[Eth_MacType_2 + 1] >> 5;

            switch (pcp)
            {
                case TAS_GCL_BE:
                    agt_counter = TAS_GCL_BE;
                    break;
                case TAS_GCL_AVB_A:
                    agt_counter = TAS_GCL_GUARD_BAND;
                    break;
                case TAS_GCL_CT:
                    agt_counter = TAS_GCL_CONTROL;
                    if (TAS_PREM_STATE == TAS_PREEMPTION_DISABLE) // Only Guard Band
                    {
                        EthControl.eth_type[0] = gp_read_buffer[Eth_MacType_2 + 3];
                        EthControl.eth_type[1] = gp_read_buffer[Eth_MacType_2 + 4];
                        EthInterrupt.eth_type = (uint16_t)((EthControl.eth_type[0] << 8) | EthControl.eth_type[1]);
                        R_ETHER_Write(&g_ether0_ctrl, &EthControl, ETH_HEADER_SIZE + EthInterrupt.eth_type);
                        return;
                    }
                    break;
                case TAS_GCL_AVB_B:
                    agt_counter = TAS_GCL_AVB;
                    break;
            }

            // Generate(=separate) Ethernet II Frame Architecture
            setEthernetFrame(&EthInterrupt, gp_read_buffer);

            /* Insert Ethernet Receive Frame to Linked-list-based Strict-priority Queue */
            /* The message frame is selected to enter the corresponding queue
               for forwarding according to the PCP[Priority Code Point] of frame. */
            RQ_enqueue(&EthInterrupt, last_in_queue);
            break;
        default:
            break;
    }
}
/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
